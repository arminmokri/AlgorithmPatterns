[< Back To Algorithm Patterns](../../)

# Dynamic Programming Algorithm Patterns
### Please support my repo with your star.

## Concept
Dynamic Programming (DP) is a method for solving complex problems by breaking them down into simpler overlapping subproblems, storing the results of these subproblems to avoid redundant computation (memoization or tabulation). It’s typically used to optimize recursive solutions and improve time complexity by reusing previously computed results.

## When to Use
Use DP when a problem has **overlapping subproblems** and **optimal substructure**, meaning the global optimal solution can be built from optimal solutions of smaller subproblems. Common in problems involving counting, optimization, decision-making over stages, and minimizing/maximizing cost.

## Common Operations
- Defining states and transition relations
- Recursion with memoization (top-down) or iteration with tabulation (bottom-up)
- Managing base cases
- Using 1D or 2D arrays (or dictionaries) to store computed results

## Examples
- [Climbing Stairs](climbing_stairs) → [LeetCode](https://leetcode.com/problems/climbing-stairs) ❌
- [Longest Increasing Subsequence](longest_increasing_subsequence) → [LeetCode](https://leetcode.com/problems/longest-increasing-subsequence) ❌
- [Coin Change - Minimum Coins To Make Sum](coin_change_min_coins) → [LeetCode](https://leetcode.com/problems/coin-change) ❌
- [House Robber](house_robber) → [LeetCode](https://leetcode.com/problems/house-robber) ❌
- [Edit Distance](edit_distance) → [LeetCode](https://leetcode.com/problems/edit-distance) ❌
- [Coin Change - Count Ways To Make Sum](coin_change_count_ways) ✅
- [Combinatorial Partitioning](combinatorial_partitioning) ✅

[< Back To Algorithm Patterns](../../)
